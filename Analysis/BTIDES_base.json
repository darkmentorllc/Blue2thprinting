{
  "$id": "http://darkmentor.com/BTIDES_Schema/BTIDES.html",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "description": "BlueTooth Information Data Exchange Schema (BTIDES!)",
  "type": "object",
  "required": [ "bdaddr", "bdaddr_rand" ],
  "properties": {
    "bdaddr": { "$ref": "#/definitions/bdaddr" },
    "bdaddr_rand": { "$ref": "#/definitions/bdaddr_random" },
    "bdaddr_rand_subtype": { "$ref": "#/definitions/bdaddr_random_subtype" },
    "AdvChanArray": { "$ref": "BTIDES_AdvData.json#/properties/AdvChanArray" },
    "LLArray": { "$ref": "BTIDES_LL.json#/properties/LLArray" },
    "L2CAPArray": { "$ref": "BTIDES_L2CAP.json#/properties/L2CAPArray" },
    "SMPArray": { "$ref": "BTIDES_SMP.json#/properties/SMPArray" },
    "ATTArray": { "$ref": "BTIDES_ATT.json#/properties/ATTArray" },
    "GATTArray": { "$ref": "BTIDES_GATT.json#/properties/GATTArray" },
    "LMPArray": { "$ref": "BTIDES_LMP.json#/properties/LMPArray" },
    "SDPArray": { "$ref": "BTIDES_SDP.json#/properties/SDPArray" },
    "GPSArray": { "$ref": "BTIDES_GPS.json#/properties/GPSArray" }
  },
  "definitions": {
    "bdaddr": {
        "description": "Bluetooth Device Address (BDADDR) in typical colon-deliminated-hexidecimal format. E.g. \"AA:BB:CC:DD:EE:FF\", where AA is the most significant byte",
	"type": "string"
    },
    "bdaddr_random": {
        "description": "Set to 1 if the BDADDR is a random address, and 0 if it's a public address. For BT Classic (BR/EDR) BDADDRs it should always be set to 0.",
	"type": "integer",
	"enum": [ 0, 1 ]
    },
    "bdaddr_random_subtype": {
        "description": "Optional helper data so you don't need to parse the sub-type out of the most-significant 2 bits of the BDADDR.\n 0 = \"Static\"\n 1 = \"Private Resolvable\"\n 2 = \"Private Non-Resolvable\"",
	"type": "integer",
	"enum": [0, 1, 2]
    },
    "std_optional_fields": {
	"description": "Common optional fields that can be included in a record if desired.",
	"anyOf": [
		{ "$ref": "#/definitions/time" },
		{ "$ref": "#/definitions/src_file" },
		{ "$ref": "#/definitions/RSSI" }
	]
    },
    "src_file": {
	"description": "Optional source file where this data came from. Useful for backtracking data when debugging if something was parsed correctly or not.",
	"type": "string"
    },
    "RSSI": {
	"description": "Received Signal Strength Indicator in dBm (deciBel-milliwatts) at the time this record was collected.\n Optional because it may not be available.\n But in general if you want to attempt trilateration, you'll need this.",
	"type": "integer",
	"minimum": -128,
	"maximum": 0
    },
    "time": {
        "description": "Optional field to hold timestamps in multiple possible formats.",
	"type": "object",
	"$comment": "More formats can be added as they become needed",
	"properties": {
    		"unix_time": {
			"description": "Unix seconds-since-epoch (1970-01-01 00:00:00 UTC) timestamp, as a 32-bit integer.",
			"type": "integer",
			"minimum": 0,
			"maximum": 4294967295
		},
    		"time_str1": {
			"description": "Time formatted like YYYY-MM-DD-HH-mm-ss. E.g. 2024-01-02-03-14-15 for January 2nd 2024 at 3:14AM.",
			"type": "string",
			"minLength": 19,
			"maxLength": 19
		}
	}
    },
    "UUID": {
        "description": "Must include UUID in either of the following formats",
        "anyOf": [
                {"$ref": "#/definitions/UUID16_hex_str"},
                {"$ref": "#/definitions/UUID128_hex_str"}
        ]
    },
    "UUID16_hex_str": {
	"description": "UUID16 as hex_str.",
        "type": "string",
        "minLength": 4,
        "maxLength": 4
    },
    "UUID128_hex_str": {
        "description": "UUID128 as big-endian hex str. Should be encoded *containing* dashes (because it's quicker to strip them out if needed than add them in). E.g. 6e400001-b5a3-f393-e0a9-e50e24dcca9e.",
        "type": "string",
        "minLength": 36,
        "maxLength": 36
    },
    "full_pkt_hex_str": {
	"description": "This is the original full packet data (starting from the LL header / access address) as a hex string (i.e. bytes 0x12 0x34 0x56 represented as string \"123456\" where byte 0x12 has the lowest address in the packet). Formatted as in the order and endianness outlined in the spec.\n This is just for if you want to exhange the information in an un-parsed form (and slightly save space due to less JSON overhead. Note though that we're not trying to optimize for space yet.)",
	"type": "string"
    }
  }
}
