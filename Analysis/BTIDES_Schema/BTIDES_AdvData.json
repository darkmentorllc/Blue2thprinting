{
  "$id": "https://darkmentor.com/BTIDES_Schema/BTIDES_AdvData.json",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "description": "BTIDES AdvData advertised data types",
  "type": "object",
  "properties": {
    "AdvChanArray": {
	"description": "Capture multiple types of data such as ADV\\_IND, SCAN\\_RSP, EIR, etc here.",
	"type": "array",
	"items": { "$ref": "#/definitions/AdvChanData" }
    }
  },
  "definitions": {
    "AdvChanData": {
	"description": "Data about a packet seen on an advertising channel (could be \\*ADV\\_\\* or \\*SCAN\\_\\* for BLE or EIR for BR/EDR).",
	"type": "object",
	"properties": {
		"std_optional_fields": { "$ref": "BTIDES_base.json#/definitions/std_optional_fields" },
		"type": {
			"description": "What kind of advertisement or response this data appeared in. \n 0 = ADV\\_IND\n 1 = ADV\\_DIRECT\\_IND\n 2 = ADV\\_NONCONN\\_IND\n 3 = ADV\\_SCAN\\_IND\n 10 = AUX\\_ADV\\_IND\n 20 = SCAN\\_RSP\n 21 = AUX\\_SCAN\\_RSP\n 50 = Extended Inquiry Response",
			"type": "integer",
			"enum": [0, 1, 2, 3, 10, 20, 21, 50]
		},
		"type_str": {
			"description": "What kind of advertisement or response this data appeared in, as a string.\n ADV\\_IND\n ADV\\_DIRECT\\_IND\n ADV\\_NONCONN\\_IND\n ADV\\_SCAN\\_IND\n AUX\\_ADV\\_IND\n SCAN\\_RSP\n AUX\\_SCAN\\_RSP\n EIR",
			"type": "string",
			"enum": ["ADV_IND", "ADV_DIRECT_IND", "ADV_NONCONN_IND", "ADV_SCAN_IND", "AUX_ADV_IND", "SCAN_RSP", "AUX_SCAN_RSP", "EIR" ]
		},
		"CSA": {
			"description": "Channel Selection Algorithm (from LL header). 0 = CSA #1, 1 = CSA #2. This can be obtained from pcaps, but is not typically present in HCI logs, thus it is optional.",
			"type": "integer",
			"enum": [0,1]
		},
		"full_pkt_hex_str": {"$ref": "BTIDES_base.json#/definitions/full_pkt_hex_str" },
		"AdvDataArray": {
			"description": "This is the array of *0 or more* AdvData types (where \"AdvData\" is the term used in the Spec definition of packets), like Device Name, Tx Power, Manufacturer-Specific Data (MSD), UUID16/128 lists, etc.",
			"type": "array",
			"items": {
				"anyOf": [
					{"$ref": "#/definitions/Flags"},
					{"$ref": "#/definitions/UUID16ListIncomplete"},
					{"$ref": "#/definitions/UUID16ListComplete"},
					{"$ref": "#/definitions/UUID32ListIncomplete"},
					{"$ref": "#/definitions/UUID32ListComplete"},
					{"$ref": "#/definitions/UUID128ListIncomplete"},
					{"$ref": "#/definitions/UUID128ListComplete"},
					{"$ref": "#/definitions/IncompleteName"},
					{"$ref": "#/definitions/CompleteName"},
					{"$ref": "#/definitions/DeviceID"},
					{"$ref": "#/definitions/TxPower"},
					{"$ref": "#/definitions/ClassOfDevice"},
					{"$ref": "#/definitions/PeripheralConnectionIntervalRange"},
					{"$ref": "#/definitions/UUID16ListServiceSolicitation"},
					{"$ref": "#/definitions/UUID32ListServiceSolicitation"},
					{"$ref": "#/definitions/UUID128ListServiceSolicitation"},
					{"$ref": "#/definitions/UUID16ServiceData"},
					{"$ref": "#/definitions/UUID32ServiceData"},
					{"$ref": "#/definitions/UUID128ServiceData"},
					{"$ref": "#/definitions/PublicTargetAddress"},
					{"$ref": "#/definitions/RandomTargetAddress"},
					{"$ref": "#/definitions/Appearance"},
					{"$ref": "#/definitions/AdvertisingInterval"},
					{"$ref": "#/definitions/URI"},
					{"$ref": "#/definitions/LESupportedFeatures"},
					{"$ref": "#/definitions/EncryptedAdvertisingData"},
					{"$ref": "#/definitions/ManufacturerSpecificData"}
				]
			}
		}
	}
    },
    "Flags": {
      "type": "object",
      "description": "Structure for AdvData of type 0x01 = \"Flags\"",
      "required": [ "type", "length", "flags_hex_str" ],
      "properties": {
	"type_str": {
		"description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
		"type": "string",
		"const": "Flags"
	},
	"type": {
		"description": "This should always be exactly == 0x01. (Per the assigned numbers document, \"Common Data Type\" table.)",
		"type": "integer",
		"const": 1
	},
	"length": {
		"description": "You should store whatever value actually came in from the device, because they could be sending malformed data, and if so, you want to capture that.",
		"type": "integer"
	},
        "flags_hex_str": {
		"description": "Flags field, single byte, stored as a hex string. i.e. 0x1a == string \"1a\" without any \"0x\" prefix.\n From BT Core Specification Supplement: \n bit 0 = 'LE Limited Discoverable Mode'\n  bit 1 = 'LE General Discoverable Mode'\n  bit 2 = 'BR/EDR Not Supported.'\n  bit 3 = 'Simultaneous LE and BR/EDR to Same Device Capable (Controller)'\n  bit 4 = 'Simultaneous LE and BR/EDR to Same Device Capable (Controller)' (removed in new specs.)",
		"type": "string",
		"minLength": 2,
		"maxLength": 2
	}
      }
    },
    "UUID16ListIncomplete": {
      "type": "object",
      "description": "Structure for AdvData of type 0x02 = \"Incomplete List of 16-bit Service or Service Class UUIDs.\"",
      "required": [ "type", "length" ],
      "properties": {
	"type_str": {
		"description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
		"type": "string",
		"const": "UUID16ListIncomplete"
	},
	"type": {
		"description": "This should always be exactly == 0x02. (Per the assigned numbers document, \"Common Data Type\" table.)",
		"type": "integer",
		"const": 2
	},
	"length": {
		"description": "This is 1 or more. If it's 1, it means they only have space for the type, and have included a 0-length UUID16List. Similarly if it's 3, they didn't include a full UUID16, so UUID16List should still be excluded because it's empty.",
		"type": "integer"
	},
	"UUID16List": {
		"description": "This is the array of *0 or more* UUID16s. Yes, devices can technically send an array of size 0 (this is seen more commonly with UUID32s).",
		"type": "array",
		"items": {"$ref": "BTIDES_base.json#/definitions/UUID16_hex_str"}
	}
      }
    },
    "UUID16ListComplete": {
      "type": "object",
      "description": "Structure for AdvData of type 0x03 = \"Complete List of 16-bit Service or Service Class UUIDs.\"",
      "required": [ "type", "length" ],
      "properties": {
	"type_str": {
		"description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
		"type": "string",
		"const": "UUID16ListComplete"
	},
	"type": {
		"description": "This should always be exactly == 0x03. (Per the assigned numbers document, \"Common Data Type\" table.)",
		"type": "integer",
		"const": 3
	},
	"length": {
		"description": "This is 1 or more. If it's 1, it means they only have space for the type, and have included a 0-length UUID16List. Similarly if it's 3, they didn't include a full UUID16, so UUID16List should still be excluded because it's empty.",
		"type": "integer"
	},
	"UUID16List": {
		"description": "This is the array of *0 or more* UUID16s. Yes, devices can technically send an array of size 0 (this is seen more commonly with UUID32s).",
		"type": "array",
		"items": {"$ref": "BTIDES_base.json#/definitions/UUID16_hex_str"}
	}
      }
    },
    "UUID32ListIncomplete": {
      "type": "object",
      "description": "Structure for AdvData of type 0x04 = \"Incomplete List of 32-bit Service or Service Class UUIDs.\"",
      "required": [ "type", "length" ],
      "properties": {
	"type_str": {
		"description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
		"type": "string",
		"const": "UUID32ListIncomplete"
	},
	"type": {
		"description": "This should always be exactly == 0x04. (Per the assigned numbers document, \"Common Data Type\" table.)",
		"type": "integer",
		"const": 4
	},
	"length": {
		"description": "This is 1 or more. If it's 1, it means they only have space for the type, and have included a 0-length UUID32List. Similarly if it's 3, they didn't include a full UUID32, so UUID32List should still be excluded because it's empty.",
		"type": "integer"
	},
	"UUID32List": {
		"description": "This is the array of *0 or more* UUID32s. Yes, devices can technically send an array of size 0 (this is seen more commonly with UUID32s).",
		"type": "array",
		"items": {"$ref": "BTIDES_base.json#/definitions/UUID32_hex_str"}
	}
      }
    },
    "UUID32ListComplete": {
      "type": "object",
      "description": "Structure for AdvData of type 0x05 = \"Complete List of 32-bit Service or Service Class UUIDs.\"",
      "required": [ "type", "length" ],
      "properties": {
	"type_str": {
		"description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
		"type": "string",
		"const": "UUID32ListComplete"
	},
	"type": {
		"description": "This should always be exactly == 0x05. (Per the assigned numbers document, \"Common Data Type\" table.)",
		"type": "integer",
		"const": 5
	},
	"length": {
		"description": "This is 1 or more. If it's 1, it means they only have space for the type, and have included a 0-length UUID32List. Similarly if it's 3, they didn't include a full UUID32, so UUID32List should still be excluded because it's empty.",
		"type": "integer"
	},
	"UUID32List": {
		"description": "This is the array of *0 or more* UUID32s. Yes, devices can technically send an array of size 0 (this is seen more commonly with UUID32s).",
		"type": "array",
		"items": {"$ref": "BTIDES_base.json#/definitions/UUID32_hex_str"}
	}
      }
    },
    "UUID128ListIncomplete": {
      "type": "object",
      "description": "Structure for AdvData of type 0x06 = \"Incomplete List of 128-bit Service or Service Class UUIDs.\"",
      "required": [ "type", "length" ],
      "properties": {
	"type_str": {
		"description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
		"type": "string",
		"const": "UUID128ListIncomplete"
	},
	"type": {
		"description": "This should always be exactly == 0x06. (Per the assigned numbers document, \"Common Data Type\" table.)",
		"type": "integer",
		"const": 6
	},
	"length": {
		"description": "This is 1 or more. If it's 1, it means they only have space for the type, and have included a 0-length UUID128List. Similarly if it's 3, they didn't include a full UUID128, so UUID128List should still be excluded because it's empty.",
		"type": "integer"
	},
	"UUID128List": {
		"description": "This is the array of *0 or more* UUID128s. Yes, devices can technically send an array of size 0 (this is seen more commonly with UUID128s).",
		"type": "array",
		"items": {"$ref": "BTIDES_base.json#/definitions/UUID128_hex_str"}
	}
      }
    },
    "UUID128ListComplete": {
      "type": "object",
      "description": "Structure for AdvData of type 0x07 = \"Complete List of 128-bit Service or Service Class UUIDs.\"",
      "required": [ "type", "length" ],
      "properties": {
	"type_str": {
		"description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
		"type": "string",
		"const": "UUID128ListComplete"
	},
	"type": {
		"description": "This should always be exactly == 0x07. (Per the assigned numbers document, \"Common Data Type\" table.)",
		"type": "integer",
		"const": 7
	},
	"length": {
		"description": "This is 1 or more. If it's 1, it means they only have space for the type, and have included a 0-length UUID128List. Similarly if it's 3, they didn't include a full UUID128, so UUID128List should still be excluded because it's empty.",
		"type": "integer"
	},
	"UUID128List": {
		"description": "This is the array of *0 or more* UUID128s. Yes, devices can technically send an array of size 0 (this is seen more commonly with UUID128s).",
		"type": "array",
		"items": {"$ref": "BTIDES_base.json#/definitions/UUID128_hex_str"}
	}
      }
    },
    "IncompleteName": {
      "type": "object",
      "$comment": "Going with a schema name of \"Incomplete\" rather than the terser \"Short\", because I think that term is more explicit about the truncation that could be occurring, for people learning about BT. (See \"Wingman Rem\" vs. \"Wingman Remote\" names)",
      "description": "Structure for AdvData of type 0x08 = \"Shortened Local Name\".",
      "required": [ "type", "length", "name" ],
      "properties": {
	"type_str": {
		"description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
		"type": "string",
		"const": "IncompleteName"
	},
	"type": {
		"description": "This should always be exactly == 0x08. (Per the assigned numbers document, \"Common Data Type\" table.)",
		"type": "integer",
		"const": 8
	},
	"length": {
		"description": "This can be any length, up to the amount of space available in a packet.",
		"type": "integer",
		"$comment": "The extended advertisements can have larger lengths to work with, so I'm just putting a simple, possibly-incorrect, sanity check on the length to warn of possible future errors",
		"minimum": 1,
		"maximum": 255
	},
        "name": {
		"description": "AKA \"Short Name\", this is a name string where the device is telling you explicitly that it couldn't fit the entire string into the packet.",
		"type": "string",
		"$comment": "The extended advertisements can have larger lengths to work with, so I'm just putting a simple, possibly-incorrect, sanity check on the length to warn of possible future errors",
		"minLength": 0,
		"maxLength": 255
	}
      }
    },
    "CompleteName": {
      "type": "object",
      "description": "Structure for AdvData of type 0x09 = \"Complete Local Name\".",
      "required": [ "type", "length", "name" ],
      "properties": {
	"type_str": {
		"description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
		"type": "string",
		"const": "CompleteName"
	},
	"type": {
		"description": "This should always be exactly == 0x09. (Per the assigned numbers document, \"Common Data Type\" table.)",
		"type": "integer",
		"const": 9
	},
	"length": {
		"description": "This can be any length, up to the amount of space available in a packet.",
		"type": "integer",
		"$comment": "The extended advertisements can have larger lengths to work with, so I'm just putting a simple, possibly-incorrect, sanity check on the length to warn of possible future errors",
		"minimum": 1,
		"maximum": 255
	},
        "name": {
		"description": "AKA \"Short Name\", this is a name string where the device is telling you explicitly that it couldn't fit the entire string into the packet.",
		"type": "string",
		"$comment": "The extended advertisements can have larger lengths to work with, so I'm just putting a simple, possibly-incorrect, sanity check on the length to warn of possible future errors",
		"minLength": 0,
		"maxLength": 255
	}
      }
    },
    "DeviceID": {
      "type": "object",
      "description": "Structure for AdvData of type 0x10 = \"DeviceID\". Note: Actual definition comes from Device ID **Profile** document \"EIR Transactions to Obtain Device ID Information\" section.",
      "required": [ "type", "vendor_id_source", "vendor_id", "product_id", "version" ],
      "properties": {
	"type_str": {
		"description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
		"type": "string",
		"const": "CompleteName"
	},
	"type": {
		"description": "This should always be exactly == 0x09. (Per the assigned numbers document, \"Common Data Type\" table.)",
		"type": "integer",
		"const": 9
	},
	"vendor_id_source": {
		"description": "Must be 1 for Bluetooth SIG, and 2 for USB SIG. Other values are RFU.",
		"type": "integer",
		"enum": [ 1, 2 ]
	},
        "vendor_id": {
		"description": "16-bit ID looked up according to vendor_id_source value.",
		"type": "integer",
		"minLength": 0,
		"maxLength": 65535
	},
        "product_id": {
		"description": "16-bit ID that is set to a value that is meaningful to the vendor themselves.",
		"type": "integer",
		"minLength": 0,
		"maxLength": 65535
	},
        "version": {
		"description": "16-bit ID that is set to a value that is meaningful to the vendor themselves.",
		"type": "integer",
		"minLength": 0,
		"maxLength": 65535
	}
      }
    },
    "TxPower": {
      "type": "object",
      "description": "Structure for AdvData of type 0x0A = \"Transmit Power Level\" (in dBm).",
      "required": [ "type", "length", "tx_power" ],
      "properties": {
	"type_str": {
		"description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
		"type": "string",
		"const": "TxPower"
	},
	"type": {
		"description": "This should always be exactly == 0x0A (10). (Per the assigned numbers document, \"Common Data Type\" table.)",
		"type": "integer",
		"const": 10
	},
	"length": {
		"description": "You should store whatever value actually came in from the device, because they could be sending malformed data, and if so, you want to capture that.",
		"type": "integer"
	},
        "tx_power": {
		"description": "Tx Power field, single byte, stored as a signed integer (-128 to 127)",
		"type": "integer",
		"minimum": -128,
		"maximum": 127
	}
      }
    },
    "CoD_hex_str": {
            "description": "Class of Device (CoD) field, 24 bits, as hex string.",
            "type": "string",
            "minLength": 6,
            "maxLength": 6
    },
    "ClassOfDevice": {
      "$comment": "Despite the fact that the Core Specification Supplement v11 doesn't say this can be used in advertisements, I do still see it occasionally in ADV_IND (and of course it's primarily in EIR).",
      "type": "object",
      "description": "Structure for AdvData of type 0x0D = \"Class of Device\".",
      "required": [ "type", "length", "CoD_hex_str" ],
      "properties": {
	"type_str": {
		"description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
		"type": "string",
		"const": "TxPower"
	},
	"type": {
		"description": "This should always be exactly == 0x0D (13). (Per the assigned numbers document, \"Common Data Type\" table.)",
		"type": "integer",
		"const": 13
	},
	"length": {
		"description": "You should store whatever value actually came in from the device, because they could be sending malformed data, and if so, you want to capture that.",
		"type": "integer"
	},
        "CoD_hex_str": { "$ref" : "#/definitions/CoD_hex_str" }
      }
    },
    "PeripheralConnectionIntervalRange": {
      "type": "object",
      "description": "Structure for AdvData of type 0x12 = \"Peripheral Connection Interval Range\".",
      "required": [ "type", "length", "Conn_Interval_Min_hex_str", "Conn_Interval_Max_hex_str" ],
      "properties": {
	"type_str": {
		"description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
		"type": "string",
		"const": "PeripheralConnectionIntervalRange"
	},
	"type": {
		"description": "This should always be exactly == 0x12 (18). (Per the assigned numbers document, \"Common Data Type\" table.)",
		"type": "integer",
		"const": 18
	},
	"length": {
		"description": "You should store whatever value actually came in from the device, because they could be sending malformed data, and if so, you want to capture that.",
		"type": "integer"
	},
        "Conn_Interval_Min_hex_str": {
		"description": "Connection interval minimum, 16 bits, as hex string. Technically the range should be 0x0006 to 0x0C80 (or 0xFFFF) according to the spec, but devices could misbehave, so just record exactly what was seen.",
		"type": "string",
		"minLength": 4,
		"maxLength": 4
	},
        "Conn_Interval_Max_hex_str": {
		"description": "Connection interval maximum, 16 bits, as hex string. Technically the range should be 0x0006 to 0x0C80 (or 0xFFFF) and >= Conn_Interval_Min according to the spec, but devices could misbehave, so just record exactly what was seen.",
		"type": "string",
		"minLength": 4,
		"maxLength": 4
	}
      }
    },
    "UUID16ListServiceSolicitation": {
      "type": "object",
      "description": "Structure for AdvData of type 0x14 = \"List of 16-bit Service Solicitation UUIDs\".",
      "required": [ "type", "length", "UUID16List" ],
      "properties": {
	"type_str": {
		"description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
		"type": "string",
		"const": "UUID16ListServiceSolicitation"
	},
	"type": {
		"description": "This should always be exactly == 0x14 (20). (Per the assigned numbers document, \"Common Data Type\" table.)",
		"type": "integer",
		"const": 20
	},
	"length": {
		"description": "You should store whatever value actually came in from the device, because they could be sending malformed data, and if so, you want to capture that.",
		"type": "integer"
	},
	"UUID16List": {
		"description": "This is the array of *0 or more* UUID16s. Yes, devices can technically send an array of size 0 (this is seen more commonly with UUID32s).",
		"type": "array",
		"items": {"$ref": "BTIDES_base.json#/definitions/UUID16_hex_str"}
	}
      }
    },
    "UUID32ListServiceSolicitation": {
      "type": "object",
      "description": "Structure for AdvData of type 0x1F = \"List of 32-bit Service Solicitation UUIDs\".",
      "required": [ "type", "length", "UUID32List" ],
      "properties": {
	"type_str": {
		"description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
		"type": "string",
		"const": "UUID32ListServiceSolicitation"
	},
	"type": {
		"description": "This should always be exactly == 0x1F (31). (Per the assigned numbers document, \"Common Data Type\" table.)",
		"type": "integer",
		"const": 31
	},
	"length": {
		"description": "You should store whatever value actually came in from the device, because they could be sending malformed data, and if so, you want to capture that.",
		"type": "integer"
	},
	"UUID32List": {
		"description": "This is the array of *0 or more* UUID32s. Yes, devices can technically send an array of size 0 (this is seen more commonly with UUID32s).",
		"type": "array",
		"items": {"$ref": "BTIDES_base.json#/definitions/UUID32_hex_str"}
	}
      }
    },
    "UUID128ListServiceSolicitation": {
      "type": "object",
      "description": "Structure for AdvData of type 0x15 = \"List of 128-bit Service Solicitation UUIDs\".",
      "required": [ "type", "length", "UUID128List" ],
      "properties": {
	"type_str": {
		"description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
		"type": "string",
		"const": "UUID128ListServiceSolicitation"
	},
	"type": {
		"description": "This should always be exactly == 0x15 (21). (Per the assigned numbers document, \"Common Data Type\" table.)",
		"type": "integer",
		"const": 21
	},
	"length": {
		"description": "You should store whatever value actually came in from the device, because they could be sending malformed data, and if so, you want to capture that.",
		"type": "integer"
	},
	"UUID128List": {
		"description": "This is the array of *0 or more* UUID128s. Yes, devices can technically send an array of size 0 (this is seen more commonly with UUID32s).",
		"type": "array",
		"items": {"$ref": "BTIDES_base.json#/definitions/UUID128_hex_str"}
	}
      }
    },
    "UUID16ServiceData": {
      "type": "object",
      "description": "Structure for AdvData of type 0x16 = \"Service Data - 16-bit UUID\".",
      "required": [ "type", "length", "UUID16", "service_data_hex_str" ],
      "properties": {
	"type_str": {
		"description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
		"type": "string",
		"const": "UUID16ServiceData"
	},
	"type": {
		"description": "This should always be exactly == 0x16 (22). (Per the assigned numbers document, \"Common Data Type\" table.)",
		"type": "integer",
		"const": 22
	},
	"length": {
		"description": "You should store whatever value actually came in from the device, because they could be sending malformed data, and if so, you want to capture that.",
		"type": "integer"
	},
	"UUID16": {"$ref": "BTIDES_base.json#/definitions/UUID16_hex_str"},
	"service_data_hex_str": {
		"description": "The raw service data as a hex string.",
		"type": "string"
	}
      }
    },
    "UUID32ServiceData": {
      "type": "object",
      "description": "Structure for AdvData of type 0x20 = \"Service Data - 32-bit UUID\".",
      "required": [ "type", "length", "UUID32", "service_data_hex_str" ],
      "properties": {
	"type_str": {
		"description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
		"type": "string",
		"const": "UUID32ServiceData"
	},
	"type": {
		"description": "This should always be exactly == 0x20 (32). (Per the assigned numbers document, \"Common Data Type\" table.)",
		"type": "integer",
		"const": 32
	},
	"length": {
		"description": "You should store whatever value actually came in from the device, because they could be sending malformed data, and if so, you want to capture that.",
		"type": "integer"
	},
	"UUID32": {"$ref": "BTIDES_base.json#/definitions/UUID32_hex_str"},
	"service_data_hex_str": {
		"description": "The raw service data as a hex string.",
		"type": "string"
	}
      }
    },
    "UUID128ServiceData": {
      "type": "object",
      "description": "Structure for AdvData of type 0x21 = \"Service Data - 128-bit UUID\".",
      "required": [ "type", "length", "UUID128", "service_data_hex_str" ],
      "properties": {
	"type_str": {
		"description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
		"type": "string",
		"const": "UUID128ServiceData"
	},
	"type": {
		"description": "This should always be exactly == 0x21 (33). (Per the assigned numbers document, \"Common Data Type\" table.)",
		"type": "integer",
		"const": 33
	},
	"length": {
		"description": "You should store whatever value actually came in from the device, because they could be sending malformed data, and if so, you want to capture that.",
		"type": "integer"
	},
	"UUID128": {"$ref": "BTIDES_base.json#/definitions/UUID128_hex_str"},
	"service_data_hex_str": {
		"description": "The raw service data as a hex string.",
		"type": "string"
	}
      }
    },
    "PublicTargetAddress": {
      "type": "object",
      "description": "Structure for AdvData of type 0x17 = \"Public Target Address\".",
      "required": [ "type", "length", "public_bdaddr" ],
      "properties": {
	"type_str": {
		"description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
		"type": "string",
		"const": "PublicTargetAddress"
	},
	"type": {
		"description": "This should always be exactly == 0x17 (23). (Per the assigned numbers document, \"Common Data Type\" table.)",
		"type": "integer",
		"const": 23
	},
	"length": {
		"description": "You should store whatever value actually came in from the device, because they could be sending malformed data, and if so, you want to capture that.",
		"type": "integer"
	},
	"public_bdaddr": {"$ref": "BTIDES_base.json#/definitions/bdaddr"}
      }
    },
    "RandomTargetAddress": {
      "type": "object",
      "description": "Structure for AdvData of type 0x18 = \"Random Target Address\".",
      "required": [ "type", "length", "random_bdaddr" ],
      "properties": {
	"type_str": {
		"description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
		"type": "string",
		"const": "RandomTargetAddress"
	},
	"type": {
		"description": "This should always be exactly == 0x18 (24). (Per the assigned numbers document, \"Common Data Type\" table.)",
		"type": "integer",
		"const": 24
	},
	"length": {
		"description": "You should store whatever value actually came in from the device, because they could be sending malformed data, and if so, you want to capture that.",
		"type": "integer"
	},
	"random_bdaddr": {"$ref": "BTIDES_base.json#/definitions/bdaddr"}
      }
    },
    "Appearance": {
      "type": "object",
      "description": "Structure for AdvData of type 0x19 = \"Appearance\".",
      "required": [ "type", "length", "appearance_hex_str" ],
      "properties": {
	"type_str": {
		"description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
		"type": "string",
		"const": "Appearance"
	},
	"type": {
		"description": "This should always be exactly == 0x19 (25). (Per the assigned numbers document, \"Common Data Type\" table.)",
		"type": "integer",
		"const": 25
	},
	"length": {
		"description": "You should store whatever value actually came in from the device, because they could be sending malformed data, and if so, you want to capture that.",
		"type": "integer"
	},
	"appearance_hex_str": {
		"description": "16-bit Appearance value as a hex string.",
		"type": "string",
		"minLength": 4,
		"maxLength": 4
	}
      }
    },
    "AdvertisingInterval": {
      "type": "object",
      "description": "Structure for AdvData of type 0x1A = \"Advertising Interval\".",
      "required": [ "type", "length", "advertising_interval" ],
      "properties": {
	"type_str": {
		"description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
		"type": "string",
		"const": "Appearance"
	},
	"type": {
		"description": "This should always be exactly == 0x1A (26). (Per the assigned numbers document, \"Common Data Type\" table.)",
		"type": "integer",
		"const": 26
	},
	"length": {
		"description": "You should store whatever value actually came in from the device, because they could be sending malformed data, and if so, you want to capture that.",
		"type": "integer"
	},
	"advertising_interval": {
		"description": "16, 24, or 32-bit Advertising Interval in units of 625us",
		"type": "integer",
		"minimum": 0,
		"maxLength": 4294967295
	}
      }
    },
    "URI": {
      "type": "object",
      "description": "Structure for AdvData of type 0x24 = \"URI\" (Uniform Resource Identifier).",
      "required": [ "type", "length", "URI_hex_str" ],
      "properties": {
	"type_str": {
		"description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
		"type": "string",
		"const": "URI"
	},
	"type": {
		"description": "This should always be exactly == 0x24 (36). (Per the assigned numbers document, \"Common Data Type\" table.)",
		"type": "integer",
		"const": 36
	},
	"length": {
		"description": "You should store whatever value actually came in from the device, because they could be sending malformed data, and if so, you want to capture that.",
		"type": "integer"
	},
	"URI_hex_str": {
		"description": "URI as hex string. Note, there are some encoding rules for shortening the URL, so this can't just be used as a plain UTF-8 string and yield an accurate result.",
		"type": "string"
	}
      }
    },
    "LESupportedFeatures": {
      "type": "object",
      "description": "Structure for AdvData of type 0x27 = \"LE Supported Features\".",
      "required": [ "type", "length", "le_features_hex_str" ],
      "properties": {
	"type_str": {
		"description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
		"type": "string",
		"const": "LESupportedFeatures"
	},
	"type": {
		"description": "This should always be exactly == 0x27 (39). (Per the assigned numbers document, \"Common Data Type\" table.)",
		"type": "integer",
		"const": 39
	},
	"length": {
		"description": "You should store whatever value actually came in from the device, because they could be sending malformed data, and if so, you want to capture that.",
		"type": "integer"
	},
	"le_features_hex_str": { "$ref": "BTIDES_LL.json#/definitions/le_features_hex_str" }
      }
    },
    "EncryptedAdvertisingData": {
      "type": "object",
      "description": "Structure for AdvData of type 0x31 = \"Encrypted Advertising Data\".",
      "required": [ "type", "length", "enc_adv_data_hex_str" ],
      "properties": {
	"type_str": {
		"description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
		"type": "string",
		"const": "EncryptedAdvertisingData"
	},
	"type": {
		"description": "This should always be exactly == 0x31 (49). (Per the assigned numbers document, \"Common Data Type\" table.)",
		"type": "integer",
		"const": 49
	},
	"length": {
		"description": "You should store whatever value actually came in from the device, because they could be sending malformed data, and if so, you want to capture that.",
		"type": "integer"
	},
	"enc_adv_data_hex_str": {
		"description": "Encrypted data as a hex string.",
		"type": "string"
	}
      }
    },
    "ManufacturerSpecificData": {
      "type": "object",
      "description": "Structure for AdvData of type 0xFF = \"Manufacturer Specific Data\" (MSD)",
      "required": [ "type", "length", "company_id_hex_str", "msd_hex_str" ],
      "properties": {
	"type_str": {
		"description": "This optional field is just for if you don't care about json file size and you want more human-readable JSON output.",
		"type": "string",
		"const": "ManufacturerSpecificData"
	},
	"type": {
		"description": "This should always be exactly == 0xFF (255). (Per the assigned numbers document, \"Common Data Type\" table.)",
		"type": "integer",
		"const": 255
	},
	"length": {
		"description": "Length of the MSD (including company ID), from packet.",
		"type": "integer"
	},
	"company_id_hex_str": {
		"description": "First 2 bytes of the MSD, interpreted as a little-endian company ID. e.g. first 2 bytes were 0x4C 0x00 it should be \"004C\" (Apple). Note however that some vendors (including Apple) sometimes put their ID big endian instead of little endian. So you may sometimes have to try IDs both ways to find a match, and even if you find a match it might be spurious.",
		"type": "string",
		"minLength": 4,
		"maxLength": 4
	},
        "msd_hex_str": {
		"description": "This is the remainder of the MSD, after the first 2 bytes which are interpreted per above as the company\\_id\\_hex\\_str.",
		"type": "string"
	}
      }
    }
  }
}
